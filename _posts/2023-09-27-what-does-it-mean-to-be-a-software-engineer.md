---
title: What does it mean to be a Software Engineer?
author: seg
date: 2023-09-27 00:34:00 +0800
categories: [Software Engineering, Junior]
tags: [Technical Skills, Infrastructure Skills, Soft Skills]
image:
  path: /commons/what-does-it-mean-to-be-a-software-engineer.png
---

Software Engineer requires you to have a logical thinking mind, but not only.
This kind of profession it's also driven by contacts with other people, thus interpersonal skills are important.

You need to talk to people, you need to manage your tasks, you have to know how to solve the tasks which are 
assigned to you. You need to train your mind to solve many different problems.

You should also develop a creative way of thinking, because you need to deal with a lot of abstraction while working as 
a software engineering.

It's worth to mention that it's not always easy to know from the start `Who you want to be?`.
I think you need to choose a profession that is enjoyable for you as a person.

Anybody who is thinking to go into this profession should not worry much. Follow your feelings and jump into it, 
because there are a lot of things to learn, understand and know. 
It takes time to get there and to have that feeling of `oh, I know how to do this!` it requires patience.

Talking about past experience, it doesn't need to be strictly related to software engineering.

The knowledge accumulated during these experiences could be used to enhance your interpersonal skills.

Talking about how past experience can impact your growth in Software Engeneering, below passage is about real life examples
of our colleagues related to skills they've gained in time. They are applying these skills on day to day bases in their current profession as software engineers.

<i>"My knowledge background is not even from IT, I am a biologist and I had the pleasure to work in a lot of other professions. I have worked at a university.
Also, I have worked at a construction site when I couldn't find a job. I worked as a retailer where I had to deal with many different types of people and learn how to talk to them.

<i>While working as a retailer, I learned a lot, on `How to talk with people?`, `How to convince them?`.
That's something that I use in my day-to-day work now as a software engineer.

<i>Without this background, I think I would not be able to jump so easily into my current job.
From the software engineer perspective, my growth path actually started from the soft skills side, 
with things like talking with the customer and dealing with different type of characters.

<i>While I was doing my master degree on biology, and later on when I worked in the university, I had projects where 
I needed to coordinate with other teams, join many meetings to discuss our progress and so on.
It's kind of similar to what we are doing now in the software engineering projects, all the sprint reviews and status sharing meetings.

<i>This phase of my life has also imparted valuable lessons in logical thinking. It encourages a more analytical and less 
human-centered approach, where one must consider the components of our ecosystems and their interactions. 
This similarity has prompted me to contemplate a software as a complete entity, pondering questions like `How it works?` and `How it interacts?`.

<i>Nothing is separated in a complicated software and the same can be said for the natural environment, which we are living in."

<i>"I've started working from a young age, when I was 15 as a retailer. This gave me that possibility to interact with different people and
it opened window of how to interact with others, understanding `How they behave?` and `What their goals are?`.
This experience gave me that level of emotional intelligence that it's very useful and helpful in software engineering collaborative efforts.

<i>Since when I was little, I had a passion and interest for technology, especially the hardware part.
I was always breaking things apart and fixing them up.

<i>My first experience with software was in high school. We had this class, 
that was for learning an old programming language, PASCAL.

<i>During lessons, I was approaching the teacher like: Okay, you're dictating us how these functions 
are working or how these loops are being done, but `How can I touch this stuff? I want to build something with it!`
She gave me some directions and the first thing that I built was a program that packaged software products for windows.

<i>The experience, gave me a new perspective, I really liked and enjoyed it. 
That's when I decided that, okay, I want to learn this, I want to learn how to build stuff. I want to go into the software world, not just hardware.

<i>I decided that on my university path, I'm going to pick something related to technology itself.
However, I was selective on what I wanted to learn, didn't gave attention all the subjects in school. I liked cutting corners.
The only thing that I was learning at the time was physics and mathematics and everything else was like falling through the cracks.

<i>The problem was that I needed to have very, very good grades to get into some good university. 
But still with my grades at the time, I managed to move to Geoinformatics, which allowed me to follow the software side 
of it and understand some of the concepts I needed to learn.

<i>School is good for understanding theory, but I didn't wait for graduation to start solving problems.
Since high school I started working with different types of pet projects. 

<i>My next adventure was building software for bars (points of sales), initially started with C, later moved to C++ language.
I did a terrible job on the first iteration. The software wasn't working that well and the UI was very ugly.
The code was unmaintainable, but at least it allowed me to understand the concepts.

<i>It allowed me to understand how things were interacting, especially that was the first time that I needed to work with a database.
I understood what a database was, how to store and read data. I didn't have the full concept of what SQL was at the time. 
I learned that later on, but still I managed to build something.

<i>Thanks to past experience I'm at the point that I'm not scared of whatever programming language I need to use to solve
a given problem. I'm not an expert in some of those languages and I definitely prefer Java in my case, but I can easily take on any kind of projects.
"

Being a software engineer is not just about technical expertise. 
It's a journey that can start from early experiences, and continue through various paths. 

Every individual's journey into software engineering is unique, and past experience, 
even those unrelated to software engineering, can shape one's perspective and approach to the profession.

Based on the Software Engineering knowledge the individual accumulated expertise can be categorized as below:

Junior Level
: Somebody that has just started exploring Software Engineering.

Intermediate Level
: Somebody that has a couple of years of experience in Software Engineering. They know some set of skills from technical, infrastructure and soft side.

Senior Level
: Somebody that would be considered a tenured Software Engineer that has spent probably 5+ years in the industry and has a couple of different projects under the belt.

Lead Level
: Somebody that is able to potentially understand probably 90% of the items categorized as technical skills, has a solid knowledge of the infrastructure skills and is very good at soft skills with abilities to manage and coordinate different team members.

Expert Level
: Somebody that has mastered the entire tree of Software Engineering knowledge with regard to technical, infrastructure and soft skills.


## Technical Skills
Refer to specific knowledge and abilities required to design, develop, test, and maintain software applications and systems. 
The knowledge accumulated by understanding these skills allows a person to understand `How to solve problems with software?`.

Usually software needs to deal with data and specialized knowledge is required for knowing `How to manage data?`.
The question can be answered by building a good understanding of <b>Data Structure</b> and <b>Algorithms</b>.

Let's imagine we have some type of data that we need to manage in our software, like a birthday or certain numbers (accounting).

We need a way to manage these data during interactions while our software is running.
We need to store them, quickly search or sort, so we can remove or modify them.

The structures used to store these data represents the <b>Data Structure</b> and the operations needed to modify, search and sort data represents the <b>Algorithms</b>.

Management of data can be achieved by using different structures like: Arrays, Lists and Trees;

There are way more data structures than the three mentioned above. However, this is only the beginning stage and
for simplicity we will start referencing only some of the areas that are needed for reaching Junior Level, remaining areas will be expanded in future materials.

The next skill set is <b>Programming Languages</b>. This is the building blocks of the 
software creation process, and no software could be created without it. Well known programing languages are: Java, Python, C, C#, C++, Rust, Haskell;

The list of programming languages is long, each language can be used to solve different type of problems. 
Some languages exist only for fun, just to show a concept. In here we will focus mainly on languages which
can be used to solve various real life problems.

As you move into this direction, it is important to select a programming language and own it.
You don't need to know all possible languages, it's good to focus on understanding concepts, 
because you can apply these concepts in different type of languages if the need raises. 

As an example the concept of loops is the same in all programming languages, the syntax(how it's written)
will be different, but the behavior it's the same. A loop can be always used to iterate over a list of elements.

It's important to become an expert on a selected language of choice, because that gives you the ability to be valuable for the market
and this will increase your career options.

In the realm of technical skills, testing holds a significant place. 
It isn't something to be taken lightly, for even those starting out in their careers need to grasp its importance. 
Testing, you see, is like a toolbox that every software developer, whether junior or experienced, should acquaint themselves with.

The process isn't just about ensuring that the code works, even if it isn't the most elegantly written. 
It's about guaranteeing that it functions precisely as it's meant to, aligning with the specific requirements provided. 
This concept, perhaps elementary, encompasses various layers of testing, each with its own role and significance.

Even as a junior developer, one has to acknowledge the value of unit tests. These are the safeguarding agents, 
ensuring that the fundamental building blocks of the code are sound. 
It isn't about perfection; it's about establishing a solid foundation.

But there's a caveat. When you embark on your journey in the world of programming,
testing isn't your initial destination. You have to take a few other stops first. 
It's essential to acquaint yourself with the programming language you've chosen, 
understand its nuances, and master the tools it provides.

Your path is determined by your language choice. 
Some languages come with an array of built-in algorithms and data structures, 
while others require you to roll up your sleeves and create them from scratch. 
This is the fork in the road where you either follow the well-trodden path or venture into the wilderness of custom implementations.

This is where you begin to differentiate yourself. By creating your algorithms and data structures, 
you elevate your skill set to a different tier. It isn't just about coding; it's about craftsmanship. 
It's about delving into the intricacies and pushing the boundaries of what's possible.

And as you navigate this path, the choice of programming language dictates the frameworks available for testing. 
Each language has its ecosystem of testing tools and frameworks, each with its quirks and advantages. 
It's here that you begin to understand that testing isn't a monolithic concept but a multifaceted practice, 
evolving alongside your journey as a developer.

The world of testing is not a singular entity; it's a multi-layered landscape. 
There are distinct levels to it, like Unity, Integration, and Acceptance. 
Your expertise in these levels defines your journey, guiding you along the path and propelling you toward higher levels.

Indeed, it's a rewarding journey. It's a truth universally acknowledged that in the realm of software engineering, 
one cannot attain professionalism without the ability to deliver code that is both testable and functional. 
It's the cornerstone of your professional identity.

But let's talk about growth. In the beginning, we all start with simplicity, 
tackling straightforward problems. As time goes on, we embrace complexity and challenge ourselves 
with more intricate issues. This is how we ascend the ladder of knowledge.

With each rung, we acquire higher-level concepts and broaden our skill sets. 
We meticulously fill our buckets across these three areas, ultimately becoming more senior and more professional. 
This transformation empowers us to confront substantial business challenges, making us invaluable to our organizations.

This journey is an investment. The initial stages may seem daunting, but in the long run, it pays dividends. 
Your growth translates into increased value, and as a professional, your compensation reflects this. 
It's all about materializing that return on investment, and even though the beginning may be tough, 
the rewards are worth it in the end.

It's fascinating to consider the evolving nature of our roles in the context of different projects and companies. 
As we dive into these layers of expertise, the shades of our roles can indeed vary. 
The journey typically commences at the junior level, progresses through the ranks of regular seniority, 
and then expands into more specialized roles, such as leads, experts or architectural positions.

However, it's essential to highlight that this evolution is contingent upon gaining knowledge and experience. 
When you join a project, it's often comforting to begin with tasks that align with your current skill level. 
This gradual immersion allows you to grow organically over time, and it's within the project itself that you truly mature.

If you're fortunate to have a thoughtful manager, they'll gradually assign you more complex tasks, 
enabling you to broaden your skills and grasp a broader perspective of the project. 
This is a pivotal concept because, initially, you might only see a fraction of the code and understand 
its immediate purpose. Yet, as you navigate through numerous classes and components, you start to perceive 
not just the interactions between these code segments, but also their overarching significance within 
the software ecosystem.

This broader view doesn't materialize instantly, it's a gradual process that accompanies your growth. 
You begin to appreciate not only how the code functions, but also its role in achieving the goals of the 
software you're working on. This holistic understanding emerges as a valuable asset, enhancing your effectiveness 
as a developer.

It's a journey marked by continuous learning and expanding horizons.

Let's immerse into this perspective a bit further. At the outset of your journey, it's not uncommon to feel somewhat adrift. 
This sense of being lost can manifest when you dive into new concepts or topics and find them initially challenging to grasp. 
It's essential to recognize that this feeling is entirely acceptable—it's a natural part of the learning process.

Take, for instance, the notion of data structures and algorithms, or perhaps something as basic as arrays. 
When you first encounter these concepts, understanding them may prove elusive. Of course, the speed at which you grasp 
them can vary from person to person, with some catching on more quickly than others. Yet, there will always be certain 
concepts that are inherently challenging.

Here's the key takeaway from this experience: Focus on learning the concept itself, without the immediate pressure to 
fully comprehend its applications. As you progress along your growth path, you'll eventually reach a moment when the 
pieces start falling into place, and you begin to see how these concepts are applied in practical situations.

In a way, being a software engineer resembles gradually opening a room full of windows. Each window represents a skill 
set or a piece of knowledge. Some windows are interconnected, while others stand alone. As you open these windows one 
by one, light floods in, symbolizing knowledge. The accumulation of these skill sets allows you to comprehend how 
things are done in the realm of software development.

However, patience is the key in this profession. It demands continuous learning and a willingness to persist, 
even when the path seems obscure. Just like opening those windows one by one, your journey in software engineering 
unfolds progressively, with each new skill and concept adding to your understanding and expertise.

We touched upon the importance of having guidance, but I'd like to refine that notion. 
Instead of necessarily relying on a manager, the key lies in finding a mentor who can offer valuable insights. 
The mentor-mentee relationship isn't a lifelong commitment; it's a dynamic process that adapts as you progress 
through your career.

A mentor serves as your guide, helping you navigate the various stages of your professional journey. 
As you traverse the junior path and move on to different trajectories, you may seek out new mentors tailored to 
your evolving needs. These mentors are individuals who have walked the same path, accumulated knowledge, and 
gained practical experience.

They possess a deep understanding of the concepts and have ventured into diverse areas of expertise. 
Their experiences have given them insights into the pitfalls of specific technologies and methodologies. 
By sharing their wisdom and experiences, they enhance your understanding of various skill sets and illuminate 
how they interconnect.

In essence, mentors play a pivotal role in helping you build a comprehensive and interconnected knowledge base, 
guiding you through the ever-evolving landscape of your career.

When working on a software project, it's crucial to consider the methodology that aligns best with the project's nature and customer expectations.
If the project involves customers who highly value continuous value delivery and are open to evolving requirements, 
an Agile approach, which emphasizes iterative development and frequent releases, is typically more suitable.
This ensures that users see the value of the software early and have opportunities to provide feedback.

On the other hand, when dealing with projects that have well-defined and stable requirements, 
the Waterfall approach may be appropriate. It allows for a structured, comprehensive development process, 
often seen in large-scale projects or industries with strict compliance requirements.

The choice of development methodology should be driven by project-specific factors, 
including the level of uncertainty in requirements, customer preferences, and the project's overall goals. 
Adhering to the right methodology can greatly influence a project's success and its ability to adapt to change 
effectively.

There are a lot of skills on the technical list, it's long, and it keeps growing because technology moves ahead.

However, the one provided here is shorter and highly list recommended for Juniors:

- Programming Paradigms
  + Imperative
  + Declarative
  + Object Oriented
- Data Structure and Algorithms
  + Arrays
  + Lists
  + Trees
  + Search
  + Recursion
- Programming Languages
  + Java
  + Python
- Testing
  + Unit Testing
  + Integration Testing
  + Acceptance Testing
- Development Methodologies
  + Waterfall
  + Scrum
  + Kanban
- Development Principles
  + KISS
  + YAGNI
  + DRY
- Design Patterns
  + Implementation patterns
    * Creational
    * Structural
    * Behavioral
- Database
  + NO-SQL
    * MongoDB
  + SQL
    * PostgresSQL
    * MySQL
- APIs
  + REST API
- Authentication
  + Basci Auth
  + Digest Auth

The order of the above list defines the order in which someone should start mastering the technical skills.

## Infrastructure Skills
Refer to the specialized knowledge and abilities required to design, implement, manage, maintain environments and tools that supports software applications and systems.
The knowledge accumulated by understanding these skills allows a person to understand `How to use tools and enviroments to build and deploy softwares?`.

Infrastructure skills are supplemental to the Technical skills. Technical skills are core in becoming a
Software Engineer, while Infrastructure skills are required to increase the quality and effectiveness 
of your work. The higher the quality of your work, the more value you will bring to the business which will
translate in higher compensation for you.

Assuming that you just started this path, you should focus first on understanding Technical skills and then 
increase the effectiveness of your trait by incorporating the Infrastructure skills.

One subset of Infrastructure skills is <b>Orchestration</b> tools like Jenkins. 
This tool allows to build, test, and integrate software changes continuously. 
The tool falls under the concept of Continuous Integration within the broader Infrastructure domain. 
Jenkins is one such orchestration tool, there are other tools, but they will be discussed later.

Using orchestration tools like Jenkins is beneficial for maintaining software quality and coordinating changes in a team. 
It is technically possible to write and build software without such tools. However, doing so may lead to less maintainable software, especially for larger teams. 
As mentioned early knowing infrastructure-related concepts can improve a software engineer's quality of work but is not mandatory, particularly for junior-level engineers. 
Having a deep understanding of infrastructure is not a mandatory requirement when starting as a junior software engineer. 
Instead, it suggests that junior-level engineers should focus on acquiring a set of essential technical skills. These technical skills are considered crucial because without them, 
one cannot produce valuable software that contributes to the organization's goals. However once the tree of technical skills is mastered proper growth can be achieved by moving towards the mastering of Infrastructure skills.

Infrastructure skills encompass tasks such as managing deployments and working with cloud services.
These skills are interconnected with various aspects of software development, including writing code, 
managing data, building, testing, and ensuring that the software runs effectively.

Having a basic understanding of infrastructure can help when issues arise, as it provides context for problem-solving and collaboration. 

Here is a list of infrastructure skills highly recommended for Juniors:
- Source Control
  + GIT 
  + SVN
- Build Tools
  + Maven
- Orchestration
  + Jenkins
  + Kubernetes
- Containerization
  + Docker
- Cloud Providers
  + AWS

The order of the above list defines the order in which someone should start mastering the infrastructure skills.

## Soft Skills
Refer to non-technical, interpersonal skills and qualities that complement the technical skills required to design, develop, test, and maintain software applications and systems.
The knowledge accumulated by understanding these skills allows a person to understand `How to collaborete with others to solve problems with software?`.

The first skill that someone should possess is <b>Work Attitude</b>.

The software landscape is dynamic, often shaped by the evolving needs of the market. This dynamic nature extends to the 
programming languages we use, which may not always remain at the forefront. Client requirements also evolve as they adapt 
to changing circumstances and user expectations.

In this constantly changing environment, it's crucial not to become overly attached to a specific way of working or a 
particular technology. Projects can come and go, and sometimes, it's necessary to pivot and adapt to new circumstances. 
<b>Flexibility</b> and <b>adaptability</b> are essential traits when it comes to work attitude in this field.

The one constant in software engineering, it seems, is change itself. Change is inevitable, and it often happens rapidly. 
Therefore, as a software engineer, one must <b>become comfortable with change</b>, even to the extent of discarding work 
that is no longer relevant. What may have been relevant yesterday, may not hold the same significance tomorrow. 
As the world moves forward, so must we, continuously seeking more efficient ways of achieving our goals.

Let me share a personal experience that highlights the ever-evolving nature of software engineering. 
We were tasked with a fascinating project: anonymizing data for a customer. 

They needed a system to obscure personally identifiable information (PII) from their dataset before sharing it 
with partners. The project also required automatic data transfer to another server via SFTPs once anonymization 
was complete.

Building this solution wasn't overly complex, but it did demand a month of effort to thoroughly understand 
data patterns, devise irreversible anonymization methods, and implement robust data transfer with fail-safe mechanisms. 
We diligently tested and fine-tuned the system, eventually reaching the delivery phase.

However, just when we were ready to deliver the solution, the unexpected happened. 
The customer's business circumstances changed, leading to a fallout with their third-party partners. 
Consequently, the need for data anonymization vanished.

Now, for someone new to such experiences, this might seem like a disaster. A month's worth of work seemingly went down the drain. 
However, in the world of software engineering, this is part of the business.

The key takeaway is not to take such outcomes personally. Every project, whether it reaches its intended destination 
or not, adds to your knowledge and skill set. You've gained valuable experience, whether the solution is eventually 
deployed or not. What matters is the process and the learning it entails.

In the realm of software engineering, change is constant. Requirements shift, technologies evolve, 
and programming languages update frequently. Java, for instance, undergoes regular transformations, 
with new features introduced and old ones retired. Adaptability to change, understanding its impact on your work, 
your team, and your project, is an essential skill in this dynamic field. So, embrace change as a part of your 
journey in software engineering.

Change is a fundamental aspect of our profession, and it can manifest in various ways, 
sometimes even on a daily basis. You could have a day when you received a task, worked on it for a couple of hours, 
only to find that the requirements for that task have changed. Throughout the day, several more changes could emerge. 
While these situations might be frustrating for some, it's crucial to remember that change is inevitable.

This concept is essential because it reminds us not to become overly attached to our work and not to view these situations as failures. 
As long as we're doing our best and learning from each experience, it holds value. We gain knowledge and experience, 
even when things don't go as planned or when we encounter unfamiliar territory.

It's perfectly fine to encounter challenges and then decide that a particular path isn't the right one for us. 
We should embrace these moments and not take them personally.

The hardest part of this journey is that it requires patience. If you're an impatient person who expects quick results 
right from the start, you might find it challenging. However, as you progress in your career, you'll gain the ability 
to work more efficiently.

Equivalently important part is <b>Life Work Balance</b> and <b>Time Management</b>.

Nevertheless, it's crucial not to become overly attached to work or fall into the trap of tunnel thinking. 
Burnout is a real concern in this profession, and achieving a healthy work-life balance is paramount. 
While we may work in fantastic offices with numerous amenities, we must remember that life continues outside of work.
We have families, friends, and the world outside to explore.

Maintaining physical well-being is also crucial, given the sedentary nature of this profession. 
We recommend incorporating movement into your daily routine, even if it means taking a short walk during the workday. 
Engaging in physical hobbies, such as biking or climbing, can help strike a balance and contribute to overall well-being.

Time management plays a significant role in achieving this balance. 
Planning your day, week, and month is essential to ensure that you allocate time not only for work but also for 
personal life. It's a choice that depends on how much you want to invest in your profession and how you want to 
structure your life.

Ultimately, while software engineering offers numerous rewards, it's essential to maintain perspective, 
prioritize health and well-being, and manage time effectively to thrive in this dynamic field.

Here is a list of soft skills highly recommended for Juniors:
- Self
  + Work Attitude
  + Work-Life Balance
  + Time management
  + Task management
  + Learning
  + Regulation of emotions (tools)
  + Problem Solving
    * Troubleshooting
    * Critical Thinking
- Team
  + Working with others

The order of the above list defines the order in which someone should start mastering the infrastructure skills.

## Conclusion

In essence, being a Software Engineer is a multifaceted role that demands more than just technical prowess. 
It combines logical reasoning, effective communication, creativity, and a passion for problem-solving. 

The dynamic tech landscape requires adaptability and a constant thirst for learning. 
While the journey to becoming a successful software engineer might not always have a defined path, 
understanding the core competencies and nurturing both technical and soft skills can pave the way for a rewarding career. 

So, what does it mean to be a Software Engineer? 

It means being a strategic thinker, a team player, a lifelong learner, and, above all, a problem solver.

## Live discussion

In case you prefer to see a live discussion on the topic see conversation between our colleagues:

{% include embed/youtube.html id='Balreaj8Yqs' %}